---
title: 排序算法
date: 2022-07-25 20:19:14
tags: 数据结构
categories: 数据结构
excerpt： 排序算法
---

# 排序算法

## 时间复杂度总览

![image-20220422125050100](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220422125050100.png)

## 1.冒泡排序

![冒泡排序](https://img-blog.csdnimg.cn/img_convert/afb80e39ce7684d6330fdc66b0873abd.gif)

```java
public static void bubblesort(int[] arr){

    //冒泡排序的时间复杂度o(n*2)
    //标识符
    boolean flag = false;
    for(int i =0 ;i<arr.length-1;i++){
        for (int j = 0; j < arr.length - 1-i; j++) {
            //如果前面的数比后面的数大，则交换
            if (arr[j] > arr[j + 1]) {
                flag = true;
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }

        //在一次排序中,一次都没交换过
        if(!flag){
            break;
        }else {
            //重置flag，下次判断
            flag = false;
        }
    }
}

```

## 2.选择排序

![选择排序](https://img-blog.csdnimg.cn/img_convert/76339a259488423b03370e381ca5edb0.gif)

```java
public static void selectSort(int[] arr) {


        for (int i = 0; i < arr.length - 1; i++) {
            int minIndex = i;
            int min = arr[i];
            //第一轮
            for (int j = i + 1; j < arr.length; j++) {
                //说明定的最小值不是最小的
                if (min > arr[j]) {
                    //重置最小值
                    min = arr[j];
                    minIndex = j;
                }
            }

            //将最小值与arr[0]交换
            if(minIndex !=  i){
                arr[minIndex] = arr[i];
                arr[i] = min;
            }
        }
}
```

## 3.插入排序

![插入排序](https://img-blog.csdnimg.cn/img_convert/c894e22dcc48b03559e3087627e3dbb8.gif)

```java
 public static void insertSort(int[] arr){
        //使用逐步推导的方式

        int insertVal = 0;
        int insertIndex = 0;

        for(int i = 1; i<arr.length;i++) {
            //定义待插入的数
             insertVal = arr[i];
            //即arr[1]前面这个数的下标
             insertIndex = i - 1;
            //说明
            //insertIndex >= 0保证在给insertVal找插入位置，不越界
            //insertVal < arr[insertIndex] 待插入的数， 还没有找到插入位置
            //给insertVal找到插入位置
            while (insertIndex >= 0 && insertVal < arr[insertIndex]) {

                //就需要将arr[insertIndex]后移
                arr[insertIndex + 1] = arr[insertIndex];

                insertIndex--;

            }
            //当退出这个循环时，说明插入的位置找到
            if(insertIndex + 1 != i){
                arr[insertIndex + 1] = insertVal;
            }
        }
 }
```

## 4.希尔排序

![在这里插入图片描述](https://img-blog.csdnimg.cn/07b15ca5a0cd4d52bfe66fe0f5dba8a2.gif#pic_center)

希尔排序的时间复杂度是：O（nlogn）～O（n2），平均时间复杂度大致是O(n√n)

笔者的理解是时间复杂度取决于你所选用的gap。因为希尔排序事先将无序的数组处理了一下，使其变得部分有序

最后再在gap = 1的情况下进行插入排序，所以，我认为希尔排序是一个加强的插入排序

```java
public static void shellSort2(int[] arr) {

    for (int gap = arr.length / 2; gap > 0; gap /= 2) {
         //对数组进行分组
        for (int i = gap; i < arr.length; i++) {
            int j = i;
            int temp = arr[j];
            //变相的插入排序，不过其中的间隔不再是1，而是gap
            if (arr[j] < arr[j - gap]) {  // 优化，如果不存在arr[j - gap] > arr[j],则不执行
                while (j - gap >= 0 && temp < arr[j - gap]) {

                    arr[j] = arr[j - gap];
                    j -= gap;

                }
                arr[j] = temp;
            }

        }
    }
}
```

##    5.快速排序

![快速排序](https://img-blog.csdnimg.cn/img_convert/4ad3b539bee9bfe9a6acdba476ceed78.gif)

```java
public static void quickSort(int[] arr, int left, int right) {

    int l = left; //左索引
    int r = right; //右索引

    // pivot 中轴
    int pivot = arr[(left + right) / 2];
    int temp = 0;
    //while循环的目的是让比pivot小的值放在他的左边
    //pivot大的值放在他的右边
    while (l < r) {

        while (arr[l] < pivot) {
            l += 1;
        }
        while (arr[r] > pivot) {
            r -= 1;
        }
        //说明pivot的左右两边的值已经按照左边全部是小于pivot，右边大于pivot
        if (l >= r) {

            break;

        }

        //交换
        temp = arr[l];
        arr[l] = arr[r];
        arr[r] = temp;

        //如果交换玩后，发现这个arr[l] = pivot 相等 r-- ，前移一步
        if (arr[l] == pivot) {
            r--;
        }

        //如果交换玩后，发现这个arr[r] = pivot 相等 l++ ，前移一步
        if (arr[r] == pivot) {
            l++;
        }

    }

    //如果l  == r,必须l++ ， r --，否则栈溢出

    if (l == r) {
        l += 1;
        r -= 1;
    }
    //向左递归
    if (left < r) {
        quickSort(arr, left, r);
    }
    //向右递归
    if (right > l) {
        quickSort(arr, l, right);
    }


}
```

## 6.基数排序

![img](https://upload-images.jianshu.io/upload_images/1940317-0fbcf53f27e12a87.gif?imageMogr2/auto-orient/strip|imageView2/2/w/959/format/webp)

```java
//基数排序,又称桶排序
public static void radixSort(int[] arr) {

    //得到每个数组最大的数
    int max = arr[0];  //假设第一个数据是最大的数
    for (int i = 0; i < arr.length; i++) {

        if (arr[i] > arr[0]) {

            max = arr[i];
        }


    }

    //得到最大的数字几位数
    int maxLength = (max + "").length();


    //第一轮（针对每个元素的个位数进行处理）

    //定义一个二维数组，表示10个桶

    int[][] bucket = new int[10][arr.length];


    //为了记录每个桶中实际存放了多少个数据，我们定义一个一维数组来记录各个桶每次放入的数据个数
    int[] bucketElementCounts = new int[10];


    //这里使用循环处理maxLength
    for (int i = 0, n = 1; i < maxLength; i++, n *= 10) {
        for (int j = 0; j < arr.length; j++) {
            //取出每个元素的各位
            int digitOfElement = arr[j] / n % 10;
            //放入到对应的桶中
            bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];

            bucketElementCounts[digitOfElement]++;

        }
        //按照这个桶的顺序取数据
        int index = 0;

        for (int k = 0; k < 10; k++) {
            //如果桶中有数据，我们才放回原数组
            if (bucketElementCounts[k] != 0) {
                //循环第k个桶，即第k个以为数组
                for (int l = 0; l < bucketElementCounts[k]; l++) {
                    //取出元素放入到array中
                    arr[index] = bucket[k][l];
                    index++;
                }
            }
            //第一轮后，需要bucketElementCounts置0

            bucketElementCounts[k] = 0;


        }

    }
}
```

## 7.归并排序

![这里写图片描述](https://img-blog.csdn.net/20180809102227861?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNDcyMzI4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

```java
/**
 *
 * @param arr   需要排序的原始数组
 * @param left   左边有序序列的初始索引
 * @param mid     中间索引
 * @param right   右边的索引
 * @param temp     中转数组
 */
public static void merge(int[] arr, int left, int mid, int right, int[] temp) {

    int i = left;   //初始化i，左边有序序列的初始索引

    int j = mid + 1;    //初始化j，右边有序序列的初始索引

    int t = 0;  //指向temp数组的当前索引

    //(-)
    //先把左右两边的数据按规则填充到temp中
    //知道左右两边的有序序列，有一边处理完毕
    while (i <= mid && j <= right) {
        if (arr[i] <= arr[j]) {
            temp[t] = arr[i];
            t++;
            i++;
        } else {
            temp[t] = arr[j];
            t++;
            j++;
        }
    }

    //(二)
    // 把有剩余数据的一方的数据一次全部填充到temp去
    while (i <= mid) {   //说明左边的序列还有剩余元素
        temp[t] = arr[i];
        t++;
        i++;

    }

    while (j <= right) {   //说明右边的序列还有剩余元素
        temp[t] = arr[j];
        t++;
        j++;

    }
    //(三)
    //将temp数组的元素拷贝到Arrays
    t = 0;
    int tempLeft = left;
    while (tempLeft <= right) {
        arr[tempLeft] = temp[t];
        t++;
        tempLeft++;
    }


}
```

