---
title: 链表
date: 2022-07-25 20:18:50
tags: 数据结构
categories: 数据结构
excerpt： 链表
---





# 链表



## 1.单链表的基本操作

####            1.增加操作

​            单链表的增加操作

```java
//添加方法
 public void add(Student student){

     //头结点不能动，需要辅助节点
     Student temp  =head;

     while (true){
         if(temp.next == null){
             break;
         }
         temp =temp.next;
     }

     temp.next = student;
     
 }
```

#### 2.修改操作

​        单链表的修改操作

```java
//修改操作
public void update(Student student){

    //头结点不能动，需要辅助节点
    Student temp = head;
    //标识符，判断找到值,默认值为false
    Boolean flag = false;

    if(head.next == null){
        System.out.println("链表为空");
        return;
    }

    while (true){
        if(temp.number == student.number){
            flag = true;                      //找到该节点
            break;
        }
        temp = temp.next;
    }

    if(flag){
        
        temp.name = student.name;
    }else{
        sout("没有找到该节点");
    }
    
}
```

#### 3.删除操作

​        单链表的删除操作

```java
//删除操作
public void delete(int number){

    //辅助节点
    Student temp = head;
    //判断是否找到该节点的标识
    Boolean flag = false;

    //判断链表为空
    if(head.next == null){
        System.out.println("链表为空");
        return;
    }

    while (true){
        if(temp.next == null){
            break;
        }
        if(temp.next.number == number){
            //这里需要遍历到该节点的上一个节点，因为删除时需要用该节点的上一个节点指向下一个节点
            flag = true;
            break;
        }
        temp =temp.next;
    }

    if(flag){
        temp.next =temp.next.next;
    }
    else {
        System.out.println("没有找到该节点");
    }
}
```

#### 4.遍历链表

​       遍历链表

```java
 //遍历链表操作
public void  list(){

       //头结点不能动
    Student temp = head.next;
    
    
    if(head.next == null){
        System.out.println("链表为空");
        return;
    }

    while (true){
        
        System.out.println(temp);
        
        temp =temp.next;
        
        if(temp == null){
            break;
        }
        
    }
}
```

#### 5.插入操作

​            插入链表的操作

```java
//插入操作
    public void insert(Student student){

         //获取辅助节点
        Student temp = head.next;
        //标识符
        Boolean flag = false ;      //是否找到该节点

        //判断是否为空链表
        if(head.next == null){
            System.out.println("链表为空");
        }
        
       while (true){
           if(temp == null){
               break;
           }
           if(temp.next.number == student.number){
               flag = true;
               System.out.println("已有编号");
               break;
           }
           if(temp.next.number > student.number){
               break;
           }
           temp = temp.next;
       }

       if(flag){
           System.out.println("已有编号");
       }else {
           student.next = temp.next;
           temp.next = student;
       }
    }
```

## 2.单链表的练习题

#### 1.冲击单链表的节点个数

```java
//获取单链表中的节点格式
public int getHeadLength(Student head){
    //判断是否为空链表
    if(head.next == null){
        return 0;
    }

    int length = 0 ;     //计数
    Student cur = head.next;   //辅助节点

    while (true){
        if(cur != null){
            length++;
            cur =cur.next;
        }
        else {
            break;
        }
    }
    return length;
}
```

#### 2.查询链表中的倒数第k个节点

```java
//查询链表中倒数第k个节点
//思路：先求出链表的长度size，再用（size - index)
public Student getLastIndexStudent(Student head,int index){
    //判断链表是否为空
    if(head.next == null){
        System.out.println("链表为空");
    }

    int size = 0; //求出链表的总长度
    int length = 0;
    //定义辅助节点
    Student cur = head.next;

    //遍历求出链表长度
    while (true){
        if(cur != null){
            size++;
            cur =cur.next;
        }
       else {
           break;
        }
    }
    //重新定位
    cur =head.next;
    while (true){
        if(length == size - index){
            break;
        }
        cur =cur.next;
        length++;
    }
    return cur;
}
```

#### 3.单链表反转

```java
public static void reverseList(HeroNode head){
     //如果当前链表为空，或者只有一个节点，无需翻转
    if(head.next == null || head.next.next == null){
        return ;
    }

    //定义一个辅助的变量，帮助我们遍历原来的链表
     HeroNode cur = head.next;
    //定义指向当前节点的下一个节点
     HeroNode next = null;
     HeroNode reverseHead = new HeroNode(0,"","");
     //遍历原来的链表，每遍历一个节点，就放在reversHead的前端。
     while (cur != null){
         next = cur.next; //先暂时保存当前节点的下一个节点
         cur.next = reverseHead.next;  //将cur的下一个节点指向链表的最前端
         reverseHead.next = cur;
         cur = next;   // 让cur后移
     }
     //将head.next 指向 reverseHead.next;
    head.next = reverseHead.next;
}
```

## 2.双向链表的基本操作

 应为双向链表和单向链表的大部分操作相同，本文只贴出有差异的部分。

#### 1.增加操作

```java
//双向链表的添加操作
public void add(HeroNode2 node){

    //头结点不能动，需要辅助节点进行遍历
    HeroNode2 temp =head;

    //遍历到最后一个节点
    while (true){
        if(temp.next == null){
            break;
        }
        temp =temp.next;
    }

    temp.next = node;
    node.pre = temp;

}
```

#### 2.删除操作

```java
//从双向链表中删除一个节点
    public void delete(int no){
        //判断链表是否为空
        if(head.next == null){
            System.out.println("链表为空");
        }

        boolean flag = false;       //判断是否找到该节点

        HeroNode2 temp = head.next;        //头结点不能动， 需要辅助节点遍历

        while(true){
            if(temp == null){
                break;
            }
            if(temp.no == no){
                flag = true;
                break;
            }
            temp = temp.next;
        }

        if(flag){
            temp.pre.next = temp.next;
            if(temp.next != null){

                temp.next.pre = temp.pre;
            }
        }else {
            System.out.println("找不到要删除的节点");
        }
    }
}
```

相关代码已上传到我的github，大家可以在github上查阅更详细的代码

github地址：https://github.com/hhxxccdd/data-struct.git